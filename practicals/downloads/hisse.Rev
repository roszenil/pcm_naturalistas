###################################################################
# RevBayes Analysis: HiSSE
# Authors: Rosana Zenil-Ferguson and Nicolás Castillo Rodríguez
# Last modified: 01/30/2026
###################################################################

# Proposal moves and monitors for inference (the results of an MCMC)
moves = VectorMoves()
monitors = VectorMonitors()

##############################
# Number of states and rates #
##############################

NUM_STATES <- 2
NUM_HIDDEN <- 2
NUM_RATES = NUM_STATES * NUM_HIDDEN

#######################
# Reading in the Data #
#######################

### Phylogenetic tree
observed_phylogeny <- readTrees("data/poliniza_arbol.tre")[1]

## Data
## 0 = Insect
## 1 = Wind
data <- readCharacterDataDelimited("data/poliniza_datos.csv",
                                   stateLabels=2,
                                   type="NaturalNumbers",
                                   delimiter=",",
                                   header=TRUE)

# Expand 0 and 1 to have A and B hidden states
data_exp <- data.expandCharacters(NUM_HIDDEN)

# Which taxa?
taxa <- observed_phylogeny.taxa()

# How old is the phylogenetic tree?
root_age <- observed_phylogeny.rootAge()

#####################################
# Set up the transition rate matrix #
#####################################
###### This is the version of RZF that allows for more flexibility in the transition rates both for main states and hidden states
### In the RevBayes tutorial website this section is specified differently, stronger assumptions. In my experience that is OK as long as you have a tree less than 200 trees.

# Gamma priors for rates in the Q-matrix with shape and rate parameters
shape_pr <- 0.5
rate_pr := observed_phylogeny.treeLength()/5

#Transitions between observed states
q_0A1A ~ dnGamma(shape=shape_pr, rate=rate_pr)
q_1A0A ~ dnGamma(shape=shape_pr, rate=rate_pr)
q_0B1B ~ dnGamma(shape=shape_pr, rate=rate_pr)
q_1B0B ~ dnGamma(shape=shape_pr, rate=rate_pr)
#Transitions between hidden states
q_0A0B ~ dnGamma(shape=shape_pr, rate=rate_pr)
q_0B0A ~ dnGamma(shape=shape_pr, rate=rate_pr)
q_1A1B ~ dnGamma(shape=shape_pr, rate=rate_pr)
q_1B1A ~ dnGamma(shape=shape_pr, rate=rate_pr)

moves.append(mvScale(q_0A1A, weight=2 ))
moves.append(mvScale(q_1A0A, weight=2 ))
moves.append(mvScale(q_0B1B, weight=2 ))
moves.append(mvScale(q_1B0B, weight=2 ))

moves.append(mvScale(q_0A0B, weight=2 ))
moves.append(mvScale(q_0B0A, weight=2 ))
moves.append(mvScale(q_1A1B, weight=2 ))
moves.append(mvScale(q_1B1A, weight=2 ))

# Crea una matriz de 4x4 porque son 4 estados
# The way we will build the matrix: 1=0A, 2=1A, 3=0B, and 4=1B

for (i in 1:NUM_RATES) {
for (j in 1:NUM_RATES) {
q[i][j] := 0.0
}
}

q[1][2]:= q_0A1A
q[1][3]:= q_0A0B
q[2][1]:= q_1A0A
q[2][4]:= q_1A1B
q[3][4]:= q_0B1B
q[3][1]:= q_0B0A
q[4][3]:= q_1B0B
q[4][2]:= q_1B1A

# Generate the actual matrix
rate_matrix := fnFreeK(q, rescaled=false, matrixExponentialMethod="scalingAndSquaring")

#########################
# Diversification rates #
#########################

# Specify a prior on the diversification and turnover rate
# Create the constant prior parameters of the diversification rates

total_taxa <- observed_phylogeny.ntips() # How many taxa
H = 0.5
rate_mean <- ln(ln(total_taxa/2.0) /root_age) # Magallon and Sanderson (2001)
rate_sd <- 2*H

# We will be careful for the diversification rates of 0A y 0B. We will use a multiplier called sepciation_alpha for states in A and speciation_alpha+speciation_beta for B. 
# We build them this way because A and B are hidden states derivated from the same main state so in theory they should be not so different. However, you can decide to define them separatedly.
# Create a log normal distributed variable for the diversification rates. speciation_alpha and speciation_beta are parameters that we use to create that log normal distribution.

for (i in 1:NUM_STATES) {

speciation_alpha[i] ~ dnNormal(mean=rate_mean,sd=rate_sd)
moves.append(mvSlide(speciation_alpha[i],delta=0.20,tune=true,weight=2.0))

extinction_alpha[i] ~ dnNormal(mean=rate_mean,sd=rate_sd)
moves.append(mvSlide(extinction_alpha[i],delta=0.20,tune=true,weight=2.0))
}

for (i in 1:NUM_HIDDEN) {

speciation_beta[i] ~ dnNormal(0.0,1.0)
moves.append(mvScale(speciation_beta[i],lambda=0.20,tune=true,weight=2.0))

extinction_beta[i] ~ dnNormal(0.0,1.0)
moves.append(mvSlide(extinction_beta[i],delta=0.20,tune=true,weight=2.0))

}

for (j in 1:NUM_HIDDEN) {
for (i in 1:NUM_STATES) {
if ( j == 1) {
speciation[i] := exp( speciation_alpha[i] )
extinction[i] := exp( extinction_alpha[i] )
} else {
index = i+(j*NUM_STATES)-NUM_STATES
speciation[index] := exp( speciation_alpha[i] + speciation_beta[j-1] )
extinction[index] := exp( extinction_alpha[i] + extinction_beta[j-1] )
}
}
}

net_diversification := speciation - extinction

#######################################
# Estimate the root state frequencies #
#######################################

# Create a constant variable with the prior probabilities of each rate category at the root.

root_frequencies ~ dnDirichlet(rep(1,NUM_RATES))
moves.append(mvDirichletSimplex(root_frequencies,tune=true,weight=2))
moves.append(mvElementSwapSimplex(root_frequencies, weight=3))

##############################
# Indicate sampling fraction #
##############################

# Extant_sampling is the probability of sampling species at the present

total_clade <- 200
extant_sampling <- total_taxa/total_clade

#######################
# dnCDBDP = The model #
#######################

# Construct a variable for the tree drawn from a birth death process
# Here is where I tie speciation, extinction, and Q using a Birth-Death with categories

hisse ~ dnCDBDP(rootAge         = root_age,
                speciationRates = speciation,
                extinctionRates = extinction,
                Q               = rate_matrix,
                pi              = root_frequencies,
                rho             = extant_sampling,
                delta           = 1,
                condition       = "time")

# clamp the model with the "observed" tree
hisse.clamp(observed_phylogeny)
hisse.clampCharData(data_exp) #note the clamping on the expanded dataset

#############
# The Model #
#############

# Workspace model wrapper
mymodel = model(rate_matrix)

# Set up the monitors that will output parameter values to file and screen
monitors.append(mnModel(filename="output/hisse_pollination.log", printgen=1))
#monitors.append(mnJointConditionalAncestralState(tree=hisse, cdbdp=hisse, type="NaturalNumbers", printgen=500, withTips=true, withStartStates=false, filename="output/asr_hisse_pollination.log"))
#monitors.append(mnStochasticCharacterMap(cdbdp=hisse, printgen=500, filename="output/stochmap_hisse_pollination.log", include_simmap=true))
monitors.append(mnScreen(printgen=10, q_0A1A, q_1A0A, net_diversification))

############
# The MCMC #
############

# Creating the MCMC object
mymcmc = mcmc(mymodel, monitors, moves, nruns=2, moveschedule="random")

# Checkpoint and stopping rule
if ( fileExists("output/hisse_pollination.state") ) {
  mymcmc.initializeFromCheckpoint("output/hisse_pollination.state")
}

stopping_rules[1] = srMinESS(250, file = "output/hisse_pollination.log", freq = 10000)

# Run the MCMC
mymcmc.run(rules = stopping_rules, checkpointInterval = 1000, checkpointFile = "output/hisse_pollination.state")

##############################
# Summarize ancestral states #
##############################
### Opcional reconstruccion ancestral

#anc_states = readAncestralStateTrace("output/asr_hisse_pollination_run_1.log")
#anc_tree = ancestralStateTree(tree=observed_phylogeny, ancestral_state_trace_vector=anc_states, include_start_states=false, file="output/asr_summary_hisse_pollination_run_1.tree", burnin=0.1, summary_statistic="MAP", site = 1)

#anc_state_trace = readAncestralStateTrace("output/stochmap_hisse_pollination_run_1.log")
#characterMapTree(observed_phylogeny, anc_state_trace, character_file="output/stochmap_hisse_pollination_run_1.tree", posterior_file="output/posterior_stochmap_hisse_pollination_run_1.tree", burnin=0.1, reconstruction="marginal")

q()
